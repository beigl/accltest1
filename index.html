<!doctype html>
<html lang="de">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Beschleunigung – 10s Plot</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 10px; font: 14px system-ui, sans-serif; }
  #controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
  button { padding:8px 12px; border-radius:10px; border:1px solid #999; background:transparent; }
  .row { display:flex; flex-direction:column; gap:8px; }
  canvas { width:100%; height:22vh; border:1px solid #ccc; border-radius:12px; }
  .label { font-weight:600; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>

<div id="controls">
  <button id="startBtn">Start</button>
  <div id="status" class="mono">Idle</div>
</div>

<div class="row">
  <div class="label">X (m/s²)</div><canvas id="cx"></canvas>
  <div class="label">Y (m/s²)</div><canvas id="cy"></canvas>
  <div class="label">Z (m/s²)</div><canvas id="cz"></canvas>
</div>

<script>
(function(){
  const STATUS = document.getElementById('status');
  const startBtn = document.getElementById('startBtn');
  const canvases = { x: cx, y: cy, z: cz };
  const ctx = { x: cx.getContext('2d'), y: cy.getContext('2d'), z: cz.getContext('2d') };

  let running = false, rafId = 0;
  const windowMs = 10000;      // 10 s Fenster
  const fixedRange = 20;       // ±20 m/s²
  const buf = [];              // {t,x,y,z}
  let lastEventAt = 0;
  let accelerometerObj = null; // Generic Sensor API, falls verfügbar

  function dNow(){ return performance.now(); }

  function setStatus(msg){ STATUS.textContent = msg; }

  function resize(){
    for (const c of Object.values(canvases)) {
      const r = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.floor(c.clientWidth * r));
      const h = Math.max(1, Math.floor(c.clientHeight * r));
      if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
    }
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  function addSample(ax, ay, az){
    const t = dNow();
    buf.push({ t, x: ax ?? 0, y: ay ?? 0, z: az ?? 0 });
    const cutoff = t - windowMs;
    while (buf.length && buf[0].t < cutoff) buf.shift();
    lastEventAt = t;
  }

  function yFrom(val, H){
    const v = Math.max(-fixedRange, Math.min(fixedRange, val ?? 0));
    // + oben, - unten (invertiertes y)
    return H * (0.5 - (v / (2*fixedRange)) * 2);
  }

  function drawSeries(key, c, g){
    const tEnd = dNow(), tStart = tEnd - windowMs;
    const W = c.width, H = c.height;
    g.clearRect(0,0,W,H);

    // Grid (alle 2 s) + Nulllinie
    g.lineWidth = 1; g.globalAlpha = 0.25; g.beginPath();
    for (let s = Math.ceil(tStart/2000)*2000; s <= tEnd; s += 2000) {
      const x = ((s - tStart) / windowMs) * W; g.moveTo(x,0); g.lineTo(x,H);
    }
    g.stroke();
    g.beginPath(); g.moveTo(0,yFrom(0,H)); g.lineTo(W,yFrom(0,H)); g.stroke();
    g.globalAlpha = 1;

    // Daten
    g.lineWidth = 2; g.beginPath();
    let first = true;
    for (const p of buf) {
      if (p.t < tStart) continue;
      const x = ((p.t - tStart) / windowMs) * W;
      const y = yFrom(p[key], H);
      if (first){ g.moveTo(x,y); first=false; } else { g.lineTo(x,y); }
    }
    g.stroke();

    // Beschriftung
    g.font = Math.max(10, Math.floor(H/16)) + 'px system-ui, sans-serif';
    g.fillText('+20', 6, 14);
    g.fillText('0', 6, yFrom(0,H)-4);
    g.fillText('-20', 6, H-6);
    g.fillText('← 10s', W-48, H-6);
  }

  function render(){
    drawSeries('x', canvases.x, ctx.x);
    drawSeries('y', canvases.y, ctx.y);
    drawSeries('z', canvases.z, ctx.z);
    // Diagnose: Meldung, wenn keine Events reinkommen
    if (running) {
      const age = dNow() - lastEventAt;
      if (age > 1200) {
        setStatus('Keine Sensordaten. Prüfe HTTPS & „Bewegungssensoren erlauben“.');
      } else {
        setStatus('Running');
      }
    }
    rafId = requestAnimationFrame(render);
  }

  // --- DeviceMotion (ältere Web API) ---
  function onMotion(e){
    let ax, ay, az;
    if (e.acceleration && (e.acceleration.x!=null || e.acceleration.y!=null || e.acceleration.z!=null)) {
      ax = e.acceleration.x; ay = e.acceleration.y; az = e.acceleration.z;
    } else if (e.accelerationIncludingGravity) {
      ax = e.accelerationIncludingGravity.x;
      ay = e.accelerationIncludingGravity.y;
      az = e.accelerationIncludingGravity.z;
    } else {
      return;
    }
    addSample(ax, ay, az);
  }

  // --- Generic Sensor API (Fallback/Alternative) ---
  async function tryGenericSensor(){
    if (!('Accelerometer' in window)) return null;
    try {
      // 60 Hz Ziel, wo erlaubt
      const accel = new Accelerometer({ frequency: 60 });
      accel.addEventListener('reading', () => addSample(accel.x, accel.y, accel.z));
      accel.start();
      return accel;
    } catch (err) {
      console.warn('Generic Sensor failed:', err);
      return null;
    }
  }

  function hasDeviceMotion(){
    return 'ondevicemotion' in window;
  }

  async function start(){
    if (running) return;
    running = true; lastEventAt = 0;
    setStatus('Start…');

    // iOS-Permission (auf Android meist nicht nötig)
    let permPromise = Promise.resolve();
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      permPromise = DeviceMotionEvent.requestPermission().catch(()=>{ throw new Error('Permission denied'); });
    }

    try {
      await permPromise;
      // Event-Listener
      if (hasDeviceMotion()) {
        window.addEventListener('devicemotion', onMotion, {passive:true});
      }
      // Zusätzlich versuchen wir die Generic-Sensor-API
      accelerometerObj = await tryGenericSensor();

      // Wenn beide fehlen, sofort Hinweis
      if (!hasDeviceMotion() && !accelerometerObj) {
        setStatus('Kein Sensor-API verfügbar. Chrome aktualisieren / HTTPS nutzen / Einstellungen prüfen.');
      } else {
        setStatus('Running');
      }

      render();
    } catch (e){
      running = false;
      setStatus('Zugriff verweigert oder nicht verfügbar.');
    }
  }

  function stop(){
    if (!running) return;
    running = false;
    cancelAnimationFrame(rafId);
    window.removeEventListener('devicemotion', onMotion);
    if (accelerometerObj && accelerometerObj.stop) accelerometerObj.stop();
    accelerometerObj = null;
    setStatus('Stopped');
  }

  startBtn.addEventListener('click', () => {
    if (!running) { start(); startBtn.textContent = 'Stop'; }
    else { stop(); startBtn.textContent = 'Start'; }
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden && running) { stop(); startBtn.textContent = 'Start'; }
  });

  // Initiale Umgebungshinweise
  const secure = (location.protocol === 'https:' || location.hostname === 'localhost');
  if (!secure) {
    setStatus('Hinweis: Viele Geräte senden nur über HTTPS Sensordaten.');
  }
})();
</script>
</html>
